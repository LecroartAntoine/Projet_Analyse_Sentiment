name: Build and deploy Python project to Azure Function App - Projet-Analyse-Sentiment

on:
  push:
    branches:
      - main
  workflow_dispatch:

env: # Workflow-level environment variables, accessible in all jobs
  PYTHON_VERSION: '3.10'
  AZURE_FUNCTIONAPP_ROOT_FOLDER: 'API' # Base path for function app code
  MLFLOW_REGISTERED_MODEL_NAME: 'MODEL_ADVANCED'
  MLFLOW_TRACKING_URI_RELATIVE: 'Mod√©lisation/mlruns' 
  ARTIFACT_ZIP_NAME: 'python-app.zip'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions: 
      contents: read
    env: # Job-level environment variables for the 'build' job
        # We reconstruct the path or use github.workspace directly
        # AZURE_FUNCTIONAPP_ROOT_FOLDER_JOB: 'api' # If you wanted to override or specify differently at job level
        FUNCTION_APP_MODEL_DIR_ABSOLUTE: ${{ github.workspace }}/API/model # Construct full path directly
                                                                      # Using the known value 'api' from workflow env

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 

      - name: Setup Python version
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }} # Workflow env is fine here

      - name: Install MLflow and Function App dependencies
        run: |
          python -m pip install --upgrade pip
          pip install mlflow 
          pip install -r ${{ env.AZURE_FUNCTIONAPP_ROOT_FOLDER }}/requirements.txt # Workflow env is fine here
      
      - name: Create target model directory in Function App folder
        # Use the job-level 'FUNCTION_APP_MODEL_DIR_ABSOLUTE' which was constructed correctly
        run: mkdir -p ${{ env.FUNCTION_APP_MODEL_DIR_ABSOLUTE }}

      - name: Download latest registered model and tokenizer from MLflow
        run: |
          # Ensure GITHUB_WORKSPACE is used for full paths if needed by Python os module
          FULL_MLFLOW_TRACKING_PATH_ON_RUNNER="file://${{ github.workspace }}/${{ env.MLFLOW_TRACKING_URI_RELATIVE }}"
          echo "Attempting to set MLFLOW_TRACKING_URI for Python script to: $FULL_MLFLOW_TRACKING_PATH_ON_RUNNER"
          
          python -c "
          import mlflow
          import shutil
          import os

          # Retrieve env vars passed to this python -c step
          model_name = os.environ.get('MLFLOW_REGISTERED_MODEL_NAME_SCRIPT')
          target_model_dir = os.environ.get('FUNCTION_APP_MODEL_DIR_ABSOLUTE_SCRIPT')
          # Crucially, use the tracking URI passed via env var to this script
          mlflow_tracking_uri_for_script = os.environ.get('MLFLOW_TRACKING_URI_FOR_PYTHON_SCRIPT')


          print(f'Python script received MLFLOW_TRACKING_URI_FOR_PYTHON_SCRIPT: {mlflow_tracking_uri_for_script}')
          print(f'Python script received model_name: {model_name}')
          print(f'Python script received target_model_dir: {target_model_dir}')

          if not all([model_name, target_model_dir, mlflow_tracking_uri_for_script]):
              print('One or more critical environment variables for Python script not set!')
              exit(1)

          # Explicitly set the tracking URI for THIS MLflow client instance
          mlflow.set_tracking_uri(mlflow_tracking_uri_for_script)
          print(f'Python script: MLflow tracking URI effectively set to: {mlflow.get_tracking_uri()}') # Verify this
          
          # Create a new client AFTER setting the tracking URI
          client = mlflow.tracking.MlflowClient() 
          
          try:
              print(f'Fetching latest versions for model: {model_name} using client with URI: {client._tracking_client.tracking_uri}')
              latest_version_info = client.get_latest_versions(model_name, stages=['None']) 
              if not latest_version_info:
                  print(f'No versions found for model {model_name} with stage None. Trying Production stage...')
                  latest_version_info = client.get_latest_versions(model_name, stages=['Production'])
                  if not latest_version_info:
                      print(f'No versions found for model {model_name} with stage Production either.')
                      exit(1)

              latest_model_version_obj = latest_version_info[0] 
              run_id_from_registry = latest_model_version_obj.run_id # Get the run_id
              
              print(f'Latest version for {model_name}: Version {latest_model_version_obj.version}, Run ID from registry: {run_id_from_registry}')
              print(f'DEBUG: Source URI from registry: {latest_model_version_obj.source}') # This will show the c:/ path

              # --- Key Part: Use the run_id and relative artifact_path with mlflow.artifacts.download_artifacts ---
              # This function should use the currently set tracking URI to find the run, then the relative path.

              # Artifact paths *relative to the root of the run's artifact store*
              relative_model_artifact_path = 'model/data/model.keras'
              relative_tokenizer_artifact_path = 'tokenizer/keras_tokenizer.pkl'
              
              print(f'Attempting to download from run_id: {run_id_from_registry}, artifact: {relative_model_artifact_path}')
              mlflow.artifacts.download_artifacts(
                  run_id=run_id_from_registry, # Use the run_id obtained from the registry
                  artifact_path=relative_model_artifact_path, 
                  dst_path=target_model_dir
              )
              # ... (file moving logic as before) ...

              print(f'Attempting to download from run_id: {run_id_from_registry}, artifact: {relative_tokenizer_artifact_path}')
              mlflow.artifacts.download_artifacts(
                  run_id=run_id_from_registry, # Use the run_id
                  artifact_path=relative_tokenizer_artifact_path,
                  dst_path=target_model_dir
              )
              # ... (file moving logic as before for tokenizer) ...

              print(f'Model and tokenizer should be in {target_model_dir}')
              print('Final contents of target model directory:')
              os.system(f'ls -lR {target_model_dir}')

          except Exception as e:
              print(f'ERROR in Python script: {e}')
              import traceback
              traceback.print_exc()
              exit(1)
          "

        env: 
          MLFLOW_REGISTERED_MODEL_NAME_SCRIPT: ${{ env.MLFLOW_REGISTERED_MODEL_NAME }}
          FUNCTION_APP_MODEL_DIR_ABSOLUTE_SCRIPT: ${{ env.FUNCTION_APP_MODEL_DIR_ABSOLUTE }}
          # Pass the correctly constructed Linux file URI to the Python script
          MLFLOW_TRACKING_URI_FOR_PYTHON_SCRIPT: "file://${{ github.workspace }}/${{ env.MLFLOW_TRACKING_URI_RELATIVE }}"

      - name: Zip artifact for deployment (Function App folder contents)
        run: |
          echo "Current directory before zipping: $(pwd)"
          echo "Zipping contents of ${{ env.AZURE_FUNCTIONAPP_ROOT_FOLDER }} into ../${{ env.ARTIFACT_ZIP_NAME }}"
          cd ${{ env.AZURE_FUNCTIONAPP_ROOT_FOLDER }} # Uses workflow env
          zip -r ../${{ env.ARTIFACT_ZIP_NAME }} . -x "*venv/*" -x "*.git/*" -x "*__pycache__/*" # Uses workflow env
          cd .. 
          echo "Zip file created at: $(pwd)/${{ env.ARTIFACT_ZIP_NAME }}" # Uses workflow env
          ls -l ${{ env.ARTIFACT_ZIP_NAME }} # Uses workflow env


      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: python-app-artifact
          path: ${{ env.ARTIFACT_ZIP_NAME }} # Uses workflow env

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-function.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: python-app-artifact

      - name: List files after download
        run: ls -lR

      - name: 'Deploy to Azure Functions'
        uses: Azure/functions-action@v1
        id: deploy-to-function
        with:
          app-name: 'Projet-Analyse-Sentiment'
          slot-name: 'Production'
          package: ${{ env.ARTIFACT_ZIP_NAME }} # Uses workflow env
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_18963F46B19E49D5A57355029EB94F04 }}